---
marp: true
header: "単体テストの力 : 持続可能なソフトウェア開発を目指して"
paginate: true
style: |
  section {
    font-size: 1.6rem
  }
---
<!-- 
_header: "" 
_footer: ""
_paginate: false
-->
# 単体テストの力 : 持続可能なソフトウェア開発を目指して

伊藤 遼太

---

このスライドでは、主に「単体テストの考え方・使い方」にて得られる知見を参考にしています。

単体テストの目的から、具体的なプラティクスまで、効果的な単体テストアプローチが生み出す価値が説明できることを目標としています。

![bg contain right:36%](https://book.mynavi.jp/files/topics/134252_ext_06_0.jpg?v=1670578534)

---
# 目次

1. 単体テストの目的
2. テストを書く際のメンタルモデル
3. テストの手法とトレードオフ
4. 設計と単体テスト
5. モックの利用と壊れやすさとの関係
6. プラクティス

![bg contain right:40%](https://2.bp.blogspot.com/-wDIiY076K98/UZYlQfw21AI/AAAAAAAATL0/GmJEOLE1YsU/s800/test100.png)

---
<!-- 
header: "1. 単体テストの目的" 
_header: ""
-->
# 1. 単体テストの目的

![bg contain right:40%](https://1.bp.blogspot.com/-jlHonWZdPp0/Xq5vQuVPQrI/AAAAAAABYtI/S0mjN1WK-wEJBBSS2M6xTEhEmVjM5mUwwCEwYBhgL/s400/shigoto_zaitaku_cat_man.png)

---
## それは、**ソフトウェア開発プロジェクトの成長を持続可能にする**こと。
単体テストを効果的に行うことの主なアウトカムとして、**設計の改善** がある。

- 単体テストを作成しづらいと感じるのであれば、そのテスト対象となるコードはなんらかの改善を必要としている可能性が高い
- 質の悪さの多くは、異なるコードが密結合していることが原因
- 単体テストが書きやすい = 疎結合になっている ≒ 良い設計 

<!-- 
単体テストを書きやすくする、疎結合にするためにはある程度処理を抽象化する必要がある
その過程で、モデリングなどが必要になったり、良いモデリングができるとより変更に強い設計にしていけると思っています。
-->

---

<!-- 
header: "2.テストを書く際のメンタルモデル" 
_header: ""
-->
# 2.テストを書く際のメンタルモデル

![bg contain right:35%](https://2.bp.blogspot.com/-DtljIWqNnXw/V9vCEu_ClKI/AAAAAAAA97M/7FwwjtLqCrEgQvXptZplza7llXCO-HzAQCLcB/s400/character_heart_hagane.png)

<!-- 
テストについて、多くのエンジニアが勘違いしている２つの誤りと、あるべきメンタルモデルについて話します。
-->

---
## コードは資産ではなく**負債**

- テストコードもプロダクションコードも負債として考えるべき
  - プロダクションコードとテストコードを分けて考える人が多いが、**テストコードもプロダクションコードと同じく保守していくもの。**
  - プロダクションコードを書く際に気をつけていることをテストコードにも適用していくべき
    - ex ) 良い命名を考える、共通のロジックは抽象化して切り出す、仕様変更による修正が最小限になるようにする、など

---
## コードは資産ではなく**負債**

- テストコードも最小限にすることが重要
  - テストケースは多いほど良いと思っている人もいるが、この考えは誤り。コードは資産ではなく負債だから。
    - コードが増えれば、ソフトウェアにバグが持ち込まれる経路が増えることとなり、プロジェクトを維持するコストもさらに高くなってしまう
---
## 優れたテストスイートの特徴

1. 開発サイクルに組み込まれている
2. コードベースの重要な部分だけが対象（主にビジネスロジックやドメインモデル）
3. 最小限の保守コストで最大限の価値を生み出すように設計されている

<!-- 
1. テストコードのみをまとめて時間をとって書く、などではなく、開発のサイクルとして適用していくことが大切
2. ビジネスロジックではない、言語仕様などの振る舞いに関してはテストに含めない
3. テストコードも保守していくものなので、なるべく少ないコードで最大限の価値が生み出せるようにしていく
 -->

---
<!-- 
header: "3. テストの手法とトレードオフ" 
_header: ""
-->
# 3. テストの手法とトレードオフ

![bg contain right:40%](https://2.bp.blogspot.com/-DcQOvbE6qs0/Wc8fhxykFPI/AAAAAAABHGk/Ez3eNXlm2FQcae2FB-nWV8fsle98LmgmQCLcBGAs/s550/game_item_money_rmt.png)

---
##  良い単体テストを構成する**４本の柱**
1. **退行（Regression）に対する保護**
2. **リファクタリングへの耐性**
3. **迅速なフィードバック**
4. **保守のしやすさ**

![bg contain right](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQaE6kXbRFcc4dDhMl_jvvjIPmE9ktWcFS4Q&usqp=CAU)

<!-- TODO: ここに図を載せる -->

---

## 退行（Regression）に対する保護

プロダクションコードが**間違っているのにテストが落ちてくれない**状況に対する保護
 
    ex) ライブラリのバージョンアップを行ったが、そのライブラリを
        テスト時にモックしていたためにテストが落ちなかった 
        → プロダクションでバグが起きた

### 効果的なアプローチ
- **なるべく多くのプロダクションコード**を実行するようにする
- 最も適したテスト : **End-to-End テスト**

![bg contain right:20%](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQaE6kXbRFcc4dDhMl_jvvjIPmE9ktWcFS4Q&usqp=CAU)

---

## リファクタリングへの耐性
リファクタリングを行った際に**偽陽性**（プロダクションコードの振る舞いは正しいのにテストが落ちてしまうこと）を生み出してしまうこと

    ex)
    - Aの関数のテストの際に、Aの中で呼ばれているBをモックしており、
      Bのインターフェースを変更したらAの関数のテストが落ちてしまった
    - コンポーネントで出力されるDOMを文字列でアサーションしており、
      spanタグをpタグにしたらテストが落ちてしまった（振る舞いは問題ないのに）
![bg contain right:20%](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQaE6kXbRFcc4dDhMl_jvvjIPmE9ktWcFS4Q&usqp=CAU)

---

## リファクタリングへの耐性

### 効果的なアプローチ
- **「観測可能な」** 範囲のみを検証すること。テスト対象が公開している物のみを使うこと。
- **「実装の詳細」** をテストしないこと。暗黙に呼ばれているクラスや、出力される SQL や HTML の文字列等の、実際のコードの**振る舞い**以外をテストしないこと

---

## 迅速なフィードバック

- 迅速なフィードバックを測る指標は、テストの実行時間。
- E2Eテストは実行時間が長く、外部依存等がない単体テストは実行時間が短い。

![bg contain right:20%](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQaE6kXbRFcc4dDhMl_jvvjIPmE9ktWcFS4Q&usqp=CAU)

---

## 保守のしやすさ
保守のしやすさは以下の二点で評価できる
1. テストケースを**理解すること**がどれくらい難しいのか
    - テストケースのサイズによって変わる。一般的に、コードの量が少ないほど読みやすくなり、必要に応じて変更することも簡単に行える
2. **テストを行うこと**がどのくらい難しいのか
    - いろんなものを起動させないと実行できないような場合など

![bg contain right:20%](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQaE6kXbRFcc4dDhMl_jvvjIPmE9ktWcFS4Q&usqp=CAU)

---
## 理想的なテストの探求

- ４つ全てをバランス良く満たすテストを書くことは**不可能**である。
    - 「保守のしやすさ」を除く３つの柱は互いに排反する性質だから
- ３つの中でも、**リファクタリングへの耐性を落とすことは現実ではできない**。また、保守のしやすさも落とすことはできない。
- よって、**「退行（Regression）に対する保護」** と **「迅速なフィードバック」** のトレードオフを適切に理解し、それぞれを**バランス良く満たす**テスト構成にするべきである
- その結果、**テストピラミッド**のプラクティスが適用されることが多い

<!-- 
しかし、テストピラミッドにも例外はある。システムがビジネスロジックをあまり持たず、単純なCRUDなどの場合はE2Eと単体テストの割合は大体同じになる。
 -->
---
<!-- 
header: "4. 設計と単体テスト" 
_header: ""
-->
# 4. 設計と単体テスト

![bg contain right:40%](https://2.bp.blogspot.com/-ETcMOe_Mm04/VVGVHN9s0QI/AAAAAAAAths/Sgq-gDstFtI/s400/job_3d_cad_designer.png)

---

## 良い設計が良い単体テストを導く
ヘキサゴナルアーキテクチャ

- 内側: ドメイン層
- 外側: アプリケーション層

**ドメイン層にビジネスロジックをよせ**、単体テストを書きやすくすることで自然に責務の分離ができ、疎結合で良い設計に近づく
外部システムとのコミュニケーションはモックに置き換える

![bg contain right:40%](https://qiita-image-store.s3.amazonaws.com/0/30489/f5c66a12-a500-a536-5805-eafcebab84ce.png)

<!-- 
適切にモックができたり、モックしなくても良い状態でビジネスロジックをテストできる、適切にモジュール化されていること、など
 -->

---

## この本におけるアーキテクチャ

この本ではヘキサゴナルアーキテクチャを採用しており、3層のレイヤーを定義している。
多すぎるレイヤー化はアンチパターンとしている。レイヤーを細かく分けると、それぞれのレイヤーに対するテストを書きたくなってしまうため。

<!-- TODO: ここに3層のアーキテクチャ図を載せる -->

---

<!-- 
header: "5. モックの利用と壊れやすさとの関係" 
_header: ""
-->
# 5. モックの利用と壊れやすさとの関係

![bg contain right:40%](https://1.bp.blogspot.com/-ADpYzJt1pNc/XuXxqaCMa9I/AAAAAAABZhc/641xRs5pDCwctvE8d0m0-uwZ_y71tXlDACNcBGAsYHQ/s400/display_monitor_tv_broken.png)

---

## 偽陽性を生むテスト
大抵、モックは**実装の詳細**に関心を持つことになり、実装の詳細をテストすると壊れやすいテストになる

振る舞いを変えずに内部実装を変える「リファクタリング」で偽陽性が発生する

---
## モックの考え方 : ロンドン学派と古典学派
**ロンドン学派**： 一つのクラスをテスト対象とする。他は全てモックする
**古典学派**： 「振る舞い」をテスト対象とする。テストケース同士で共通の依存がなければモックは必要ない

-  ロンドン学派のアプローチは壊れやすいテストになる可能性がある

- この本は、「古典学派」の立場。モックした方が良いテストになる場合もあるが、**基本的にはモックしない**方が望ましいという考え

---

## TIPS : ドメイン層の隔離

- ドメイン層の中でプロセス外依存（永続層など）にアクセスしたりすると、テストではそこにモックを差し込まなければ行けなくなる
    - モックを差し込まなければいけない = 内部実装を読んで、どこでどのオブジェクトが使われているか、どういう関数が呼ばれるか、というのを知っている必要がある
    - 内部実装とテストケースが紐付く = リファクタリングへの耐性が低くなる
        -  **テストコードを理解するためには内部実装を知っていなければいけない ≒ 認知負荷が上がる ≒ 保守のしやすさが低くなる**
        - **ビジネスロジックのテストの質が低くなる ≒ アプリケーションの設計の質が低くなる**

<!-- 
諸説あるかもなやつ。この本ではこの立場
 -->
---
<!-- 
header: "プラクティス" 
_header: ""
-->
# 6. プラクティス

![bg contain right:40%](https://1.bp.blogspot.com/-0nFW604PPiY/X1CK3GmbanI/AAAAAAABau4/UMsQfxrVqWEdpFGfZyr4tRxz0x_E8BWRgCNcBGAsYHQ/s400/baseball_seat_knock.png)

---

## 読みやすいテストのために

- AAA パターンを用いて記述する（準備 (Arrage), 実行 (Act), 確認 (Assert) )
  - 空白行やコメントを使ってわかりやすくする
  - １つのテストケース内で同じフェーズが複数でてこないようにする
- そのテストケースの中でのテスト対象を特定の命名を使う
  - sut (System Under Test) など
- 全てのプロパティをアサーションするよりもオブジェクトと等価なことがテストできるようにする


<!-- 
Arrageが長くなったりすると、どこがこのテストケースの主な操作なのかがわかりにくくなる
 -->

---

## 読みやすいテストのために

```kotlin
fun test() {
    // arrange
    val stub = StubObject("hoge")
    val sut = SystemUnderTestEntity.new( hoge = stub )

    // act
    val sutResult = sut.execHoge()

    // assert
    val expected = SystemUnderTestEntity.restore( hoge = "hoge" )
    assert(sutResult == expected)
}
```

---

## テストの3つの手法

| | 出力値ベース・テスト | 状態ベース・テスト | コミュニケーション・ベース・テスト |
| ---- | ---- | ---- | ---- |
|  リファクタリングへの耐性を維持するのに必要なコスト |	低い | 普通 | 普通 |
|  保守のしやすさを維持するのに必要なコスト |低い |普通 |高い |

**出力値ベースのテストが一番コストが低い。**

### 
    出力値ベース・テスト : 入力に対する出力を検証する。純粋関数のテスト
    状態ベース・テスト : 副作用を起こす関数をよんで、その後の状態（DBなど）を検証する
    コミュニケーション・ベース・テスト : モックをさして、そのモックが呼ばれたかどうかを検証する

---

## E2Eテスト 

- 結合テスト : できるだけモックしない （状態ベース・テスト / コミュニケーション・ベース・テスト）
- １件の一番長いハッピーパスと単体テストでは検証できない全ての異常ケースを検証することが適切だと考えられている

### TIPS
- １つで網羅できない場合は、いくつかに分けて検証されるようにする
- 意味のないテストは作成しない
    - 不正なメールアドレスが渡された場合、など、仮にチェックが漏れていたとしてもドメインモデルで弾かれることがわかっているようなテストケースは作成する意味がない
    - 質の悪いテストケースを作成するくらいなら、テストケースを作成しない方がまだマシ

<!-- 
* 各層におけるテストは個人的な解釈が入っていることに注意

 - 仮に本番環境に持ち込まれたとしてもデータが壊れるわけではなく、修正も容易である
- 質の悪いテストケースを作成するくらいなら、テストケースを作成しない方がまだマシ。ここでいう質の悪いテストケースとは、明確な価値をもたらさないテストケースのことを指す。
 -->
---
## 単体テスト : Application 層 / Infrastructure 層

- テスト対象によって、適切にモックをさしての検証を行う。
- 状態ベース・テストやコミュニケーションベーステストになる
- ex ) Controller / UseCase / Repository

### TIPS
- 基本的にモックをさしてのテストになるため、壊れやすいテストになる。そのため、なるべくこのテストが膨らまないようにする
- ロジックがない場合は作成する必要なし


---

## 単体テスト : Domain 層

- 出力値ベーステストが望ましい。Immutable なクラスなどであれば状態ベーステストになる
- 原則、モックは使用しない
- ex ) Entity / Domain Service 

### TIPS
- 他の層にビジネスロジックが漏れ出ないように、重要なロジックはこの層に閉じ込め、十分にテストが書けるようにする


---
<!-- 
_header: "単体テストの力 : 持続可能なソフトウェア開発を目指して" 
-->
# 完
ありがとうございました。